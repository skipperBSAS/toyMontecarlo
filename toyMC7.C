/*
Código escrito para simular:

- Coordenada (xx,yy) donde tuvo lugar la interacción del foton X
- Profundidad zz donde tuvo lugar la interacción del foton X
- Número de cargas generadas en cada interacción
- Distribución de cargas que llega a la superficie del CCD
- Numero de cargas por pixel
- Distribucion de los pixeles que conforman cada cluster

*/    

#include <random>
#include <ctime>
#include <cstdlib>
#include "fitsio.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctime>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <chrono>
// #include "Poisson.h"
using namespace std;
// #include <array>
#include "TRandom2.h"

//N0 represents the number of X-rays that interact with the CCD ////////
void toyMC7(int N0=10,int emeannumber = 10000) {

// To check distributions run int N0=100000,int emeannumber = 10.

// emeannumber: mean number of electrons generates by a X-ray //////////

// Skin depth //////////////////////////////////////////////////////////
int tau=50; 

// CCD size
int nx = 40;     // Number of pixels in x-direction
int ny = 20;     // Number of pixels in y-direction
int pixSize= 15; // Pixel size side in microns
int xSize = nx*pixSize; // x CCD size in microns
int ySize = ny*pixSize; // y CCD size in microns

int pix[xSize][ySize]; 
int xpix[xSize];
int ypix[ySize];

for (int i = 0; i < nx; ++i){
	for (int j = 0; j < ny; ++j) pix[i][j]=0;
}


// Variables for random numbers ////////////////////////////////////////
	vector<double> xx(N0);                                               
	vector<double> yy(N0);
	vector<double> zz(N0);                                               
	
	vector<double> electrons(N0);
    vector<double> sigma(N0);
    
// Book 1D-histograms //////////////////////////////////////////////////
	int binnumber = N0/500;
	
	auto h1 = new TH1D("h1","x-coordinate",binnumber,-xSize/4,1.25*xSize);
	auto h2 = new TH1D("h2","y-coordinate",binnumber,-ySize/4,1.25*ySize);
	auto h3 = new TH1D("h3","z-coordinate",binnumber,-tau/5,5*tau);
	
	double esigma= pow(emeannumber,0.5);
	auto h4 = new TH1D("h4","number of electrons",binnumber,emeannumber-5*esigma,emeannumber+5*esigma);
	auto h5 = new TH1D("h5","sigma",binnumber,-tau/10,tau/2);
	auto h6 = new TH1D("h6","spot x",binnumber,-xSize/2,3*xSize/2);
	auto h7 = new TH1D("h7","spot y",binnumber,-ySize/2,3*ySize/2);

// Book the 2D-histogram - CCD representation //////////////////////////
   TCanvas *ch2p2 = new TCanvas("ch2p2","ch2p2",30*nx,30*ny);
   TH2Poly *h2p = new TH2Poly();
   h2p->SetName("Pixels");
   h2p->SetTitle("CCD");
   gStyle->SetPalette(1);  
 
   Double_t x1,y1,x2,y2;
   x1 = 0.;
   x2 = pixSize;

   for (int i = 0; i<nx; i++) {
      y1 = 0.;
      y2 = pixSize;
      for (int j = 0; j<ny; j++) {
         h2p->AddBin(x1, y1, x2, y2); 
         y1 = y2;
         y2 = y2+pixSize;
      }
      x1 = x2;
      x2 = x2+pixSize;
      //cout<<x2<<endl;
   }

////////////////////////////////////////////////////////////////////////	
// This loop runs over each X-ray interaction //////////////////////////

for (int j = 0; j < N0; ++j){ 

	// Generate a pair (xx, yy) of uniform random numbers //////////////
	// (xx,yy) represents the coordinates of interaction in the CCD ////
		
    TRandom3 rx(0); //  seed=0  ->  different numbers every time         
    h1->Fill(xx[j]=rx.Uniform(0,xSize)); 
	                                               
    TRandom3 ry(0); //  seed=0  ->  different numbers every time         
    h2->Fill(yy[j]=ry.Uniform(0,ySize)); 
           
	////////////////////////////////////////////////////////////////////
	// Generate zz: depth in the CCD
	// An exponential random number with coefficient tau 
    
    TRandom3 rz(0); //  seed=0  ->  different numbers every time         
    h3->Fill(zz[j] = rz.Exp(tau));                    

	//cout << endl;
	//cout << "x = "<< xx[j] << " , " << "y = "<< yy[j] << " , " << "z = "<< zz[j] << endl;
    
    ////////////////////////////////////////////////////////////////////
    // emeannumber is the mean number of electrons generated by the primary electron.
    // Primary electron here is who carries the energy released 
    // by the x-ray after photoelectric interaction.
   
	// Generate a Poisson random number with mu = emeannumber //////////
	
	TRandom3 re(0); //seed=0  ->  different numbers every time
	h4->Fill(electrons[j] = re.Poisson(emeannumber)); 
	//cout << "#e = "<< electrons[j] << endl;		
	
	////////////////////////////////////////////////////////////////////
    // sigma of charge distribution on the CCD surface in microns
    // proportional to the square root of zz depth
    
    h5->Fill(sigma[j] = pow(zz[j],0.5)); 
    //cout << "sigma = "<< sigma[j] << endl;	
    
    ////////////////////////////////////////////////////////////////////
    // charge distribution on the CCD surface
    // It generates electrons[j] random numbers with
    // bivariate multinormal distribution
    
    // Coordinates x and y of each charge colected /////////////////////
    vector<double> chargex(electrons[j]);
    vector<double> chargey(electrons[j]);
    
    for (int i = 0; i < electrons[j]; ++i) {
		
		////////////////////////////////////////////////////////////////
		// rcx is the number of excited electrons after difussion     
		// Generate a gaussian random number with mean xx[j]
		TRandom3 rcx(0); //seed=0  ->  different numbers every time
		h6->Fill(chargex[i] = rcx.Gaus(xx[j],sigma[j])); 
		//cout << endl;
		//cout << "x on CCD = "<< chargex[i] << endl;	
						
		////////////////////////////////////////////////////////////////
		// rcy is the number of excited electrons after difussion     
		// Generate a gaussian random number with mean yy[j]
		TRandom3 rcy(0); //seed=0  ->  different numbers every time
		h7->Fill(chargey[i] = rcy.Gaus(yy[j],sigma[j]));
		//cout << "y on CCD = "<< chargey[j] << endl;	
	}

for (int i = 0; i < electrons[j]; ++i) h2p->Fill(chargex[i], chargey[i]);

}   // End loop over x-rays interactions

   h2p->Draw("COLZ"); // Show CCD 2D plot
	
	for (int i = 0; i < nx; ++i) {	
		for (int j = 0; j < ny; ++j) {
		
		   int bin = h2p->FindBin(i*pixSize+pixSize/2,j*pixSize+pixSize/2,0);
		   int content = h2p->GetBinContent(bin);
		   pix[i][j]=content;
		   //cout<<"i: "<<i<<" j: "<<j<<" bin "<<bin<<" content: "<<content<<endl;
		   //getchar();
		   
		}
	}
	
// Plot histograms /////////////////////////////////////////////////////

if (N0>99){
	TCanvas* canvas = new TCanvas("canvas","canvas",10,10,700,800);
	canvas->Divide(3,3);
	
	canvas->cd(1);
	gStyle->SetOptStat(10);
	h1->Draw(""); // xx 
	
	canvas->cd(2);
	gStyle->SetOptStat(10); 
	h2->Draw(""); // yy
	
	canvas->cd(3);
	gStyle->SetOptStat(10); 
	h3->Draw(""); // zz
	
	canvas->cd(4);
	gStyle->SetOptStat(10); 
	h4->Draw(""); // #e
	
	canvas->cd(5);
	gStyle->SetOptStat(10); 
	h5->Draw(""); // sigma
	
	canvas->cd(6);
	gStyle->SetOptStat(10); 
	h6->Draw(""); // x
	
	canvas->cd(7);
	gStyle->SetOptStat(10); 
	h7->Draw(""); // y
}

}
